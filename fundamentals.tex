%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Data Cleaning Rules
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Data Quality Fundamentals}
\label{sec:expl}

%\note{This section is NOT a contribution and reads way too difficult. We need to shorten it and make it easier to read, so that reviewers easily reach Section 3}

%\subsection{Data Quality}

We consider a database instance $\mathcal{D}$ with a relational schema $\mathcal{S}$. Furthermore, we consider relation $\mathcal{R} \in \mathcal{S}$ that is defined for the set of attributes $attr(\mathcal{R})$. Moreover, $dom(U_i)$ denotes the domain of an $i$-th attribute $U_i \in attr(\mathcal{R})$. For the data cleaning, we consider a set of data quality rules, which are data-agnostic and rely on data integrity constraints~\cite{AbiteboulHV95}:

A \textbf{functional dependency} (FD) on a relational schema $S$ is an expression of the form $\phi: X \rightarrow Y$ where $X \subseteq attr(\mathcal{R}) $ and $Y \subseteq attr(\mathcal{R}) $ are subsets of $\mathcal{R}'s$ attributes $attr(\mathcal{R})$. An FD holds if every pair of tuples of $\mathcal{R}$ that agree in each of attributes $X$, also agree in the $Y$ attributes. Data quality management systems leverage functional dependencies to find and correct dirty data, because these dependencies specify the semantics of the data in a declarative way. The main disadvantage of functional dependencies is that they operate solely on the schema level and are often not able to detect conflicts in real-life data. This is the case because FDs do not capture a patricular subset of data but instead always operate globally on the whole dataset.
Therefore, we consider an extension of traditional functional dependencies:  A \textbf{conditional functional dependency} (CFD) defined on the relational schema $\mathcal{S}$ is a pair $\psi(X \rightarrow Y , T_p)$,  where $X \rightarrow Y$ is a standard FD and $X \cup Y \in attr(\mathcal{R})$ and $T_p$ is a tuple pattern, which is a set of constraints holding on the particular subset $X \cup Y$ of tuples. For each $U \in X \cup Y$, the value of the attribute $U$ for $T_p$, $T_p[U]$ is either a variable value $`\_`$, or a constant $u \in dom(U)$. Data deduplication techniques use FDs to define the matching dependencies. The difference here is that matching dependencies use the notion of the similarity predicate instead of equality predicate. A \textbf{Matching Dependency} (MD) for schemas $\mathcal{S}_1$ and $\mathcal{S}_2$ is syntacticly defined as:
  $\mu: \mathcal{S}_1[X_1]\approx \mathcal{S}_2[X_2]\rightarrow \mathcal{S}_1[Y_1]\rightleftharpoons \mathcal{S}_2[Y_2]$ 
  where $X_1 \cup Y_1$ and $X_2 \cup Y_2$ are pairwise compatible sets of attributes in $attr(\mathcal{R}_1), \mathcal{R}_1\in \mathcal{S}_1$ and $attr(\mathcal{R}_2), \mathcal{R}_2\in \mathcal{S}_2$, respectively; $\approx$ indicates
  similar attributes and $\rightleftharpoons$ is called the \textit{matching operator}. In other words the matching operator $\rightleftharpoons$ indicates that for each $\mathcal{S}_1$ tuple $t_1$ and each $\mathcal{S}_2$ tuple $t_2$: $t_1[Y_1]$ and $t_2[Y_2]$ refer to the same real-world entity. Having dynamic semantics, that is pointing \textit{how} to repair data, MD forces to update $t_1[Y_1]$ and $t_2[Y_2]$ such that they have the same values \note{unclear and incorrect english, rewrite sentence}. The operator $\rightleftharpoons$ only requires that the $t_1[Y_1]$ and $t_2[Y_2]$ are identified.

